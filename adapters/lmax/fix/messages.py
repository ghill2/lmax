import pprint
from decimal import Decimal

import pandas as pd
from simplefix import FixMessage
from simplefix import FixParser

from nautilus_trader.core.datetime import dt_to_unix_nanos
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.execution.reports import OrderStatusReport
from nautilus_trader.execution.reports import TradeReport
from nautilus_trader.model.enums import LiquiditySide
from nautilus_trader.model.identifiers import AccountId
from nautilus_trader.model.identifiers import ClientOrderId
from nautilus_trader.model.identifiers import TradeId
from nautilus_trader.model.identifiers import VenueOrderId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Money
from nautilus_trader.model.objects import Price
from nautilus_trader.model.objects import Quantity
from pytower.adapters.lmax.fix.enums import parse_lmax_order_side
from pytower.adapters.lmax.fix.enums import parse_lmax_order_status
from pytower.adapters.lmax.fix.enums import parse_lmax_order_type
from pytower.adapters.lmax.fix.enums import parse_lmax_time_in_force
from pytower.adapters.lmax.fix.parsing import parse_lmax_timestamp_ns


def string_to_raw(value: str) -> bytes:
    """
    Convert a string to bytes.

    Assumes fields are delimited by character `|`

    """
    if not value.endswith("|"):
        value += "|"
    return value.replace("|", "\x01").encode("utf-8")


def downcast_message(msg: FixMessage):
    cls = _MESSAGE_TYPE_MAP.get(msg.message_type.decode())
    assert cls is not None
    # if cls is None:
    #     return None
    m = cls()
    for tag, value in msg:
        m.append_pair(tag, value)
    return m


def raw_to_message(raw: bytes) -> FixMessage | None:
    # raw = bytes(bytearray(raw).replace('|', b'\x01'))

    # Parse message
    parser = FixParser(
        allow_empty_values=True,
        #    allow_missing_begin_string=True,
        #    strip_fields_before_begin_string=False,
    )  # LMAX sends empty TargetCompID
    parser.append_buffer(raw)
    msg = parser.get_message()
    assert msg is not None
    return downcast_message(msg)


def string_to_message(value: str) -> FixMessage | None:
    """
    Convert a string to a FixMessage instance.

    Assumes fields are delimited by character `|`

    """
    return raw_to_message(string_to_raw(value))


def debug_message(msg: FixMessage) -> str:
    info = {_FIELD_MAP.get(tag): value.decode() for tag, value in msg}
    return pprint.PrettyPrinter(info, indent=4)


class Heartbeat(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "0"
        # self.append_pair(35, "0", header=True)


class TestRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "1"
        # self.append_pair(35, "1", header=True)


class ResendRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "2"
        # self.append_pair(35, "2", header=True)


class Reject(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "3"
        # self.append_pair(35, "3", header=True)


class SequenceReset(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "4"
        # self.append_pair(35, "4", header=True)


class Logout(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "5"
        # self.append_pair(35, "5", header=True)


class ExecutionReport(FixMessage):
    """
    Represents an ExecutionReport report of a single trade.

    Parameters
    ----------
    order_id : str
        The unique identifier allocated by LMAX for the order whose execution is being reported.
    secondary_exec_id : str
        Execution ID as generated by the MTF. Currently, this is only populated for Executions
        reporting a Trade where this will be a 16 character string.
        For other Executions (New, Cancel, Replace etc) this will be set to 0.
    client_order_id: ClientOrderId
        The client supplied identifier for the order whose execution is being reported.
    exec_id: str
        The unique identifier allocated by LMAX Broker to the ExecutionReport message.
    exec_type: ExecType
        Describes the type of execution being reported by this ExecutionReport message.
    ord_status: OrdStatus

    Describes the type of execution being reported by this ExecutionReport message.
    original_client_order_id: str, optional
        Conditionally required for response to an electronic Cancel or Cancel/Replace request (ExecType=PendingCancel, Replace, or Canceled). ClOrdID of the previous accepted order (NOT
            the initial order of the day) when canceling or replacing an order. (can be ``None``)

    """

    # def __init__(self,
    #             security_id: int,
    #             order_id: str,
    #             client_order_id: ClientOrderId,
    #             exec_id: str,
    #             exec_type: ExecType,
    #             ord_status: OrderStatus,
    #             account: str,
    #             order_qty: Quantity,
    #             order_type: OrderType,
    #             price: Price = None,
    #             # ord_rej_reason: str = None
    #             # secondary_exec_id: str = None,
    #             # original_client_order_id: str = None,
    #             ):

    #     super().__init__()
    #     self.message_type = "8"
    #     # self.append_pair(35, "8", header=True)

    # @classmethod
    # def from_str(self, value: str):
    #     data = {}
    #     parts = value.split("|")
    #     for tag, value in tuple(data.split("=")):
    #         data{int(tag)} = value

    #     return cls(
    #         security_id=
    #     )
    #     account_id=self._cache.account_for_venue(LMAX_VENUE).id,
    #     instrument_id=instrument.id,
    #     venue_order_id=VenueOrderId(report.get(37).decode()),  # OrderID
    #     order_side=parse_lmax_order_side(int(report.get(54))),  #  Side
    #     order_type=parse_lmax_order_type(int(report.get(40))),  #  OrdType
    #     time_in_force=parse_lmax_time_in_force(int(report.get(59))),  # TimeInForce
    #     order_status=parse_lmax_order_status(int(report.get(39))),  # OrdStatus
    #     quantity=Quantity(float(report.get(38)), instrument.size_precision), # OrderQty
    #     filled_qty=Quantity(float(report.get(14)), instrument.size_precision),  # CumQty
    #     # filled_qty=Quantity.from_int(10_000),
    #     report_id=UUID4(),
    #     ts_accepted=parse_lmax_timestamp_ns(report.get(60).decode()),  # TransactTime
    #     ts_last=parse_lmax_timestamp_ns(report.get(60).decode()),  # TransactTime
    #     ts_init=self._clock.timestamp_ns(),
    #     client_order_id=ClientOrderId(report.get(11).decode()),  # ClOrdID
    #     avg_px=Decimal(report.get(6).decode()),  # AvgPx
    #     price=Price(float(report.get(44)), instrument.price_precision)
    #             if report.get(44) is not None else None,  # Price
    #     trigger_price=Price(float(report.get(99)), instrument.price_precision)
    #                     if report.get(99) is not None else None,  # StopPx
    #     cancel_reason=report.get(58).decode() if report.get(58) is not None else None,  # Text

    @property
    def request_id(self) -> str | None:
        return self.get(790).decode() if self.get(790) is not None else None

    def to_nautilus(self, instrument: Instrument):
        return OrderStatusReport(
            account_id=AccountId(f"LMAX-{int(self.get(1))}"),
            instrument_id=instrument.id,
            venue_order_id=VenueOrderId(self.get(37).decode()),  # OrderID
            order_side=parse_lmax_order_side(int(self.get(54))),  #  Side
            order_type=parse_lmax_order_type(int(self.get(40))),  #  OrdType
            time_in_force=parse_lmax_time_in_force(int(self.get(59))),  # TimeInForce
            order_status=parse_lmax_order_status(int(self.get(39))),  # OrdStatus
            quantity=Quantity(float(self.get(38)), instrument.size_precision),  # OrderQty
            filled_qty=Quantity(float(self.get(14)), instrument.size_precision),  # CumQty
            report_id=UUID4(),
            ts_accepted=parse_lmax_timestamp_ns(self.get(60).decode()),  # TransactTime
            ts_last=parse_lmax_timestamp_ns(self.get(60).decode()),  # TransactTime
            ts_init=dt_to_unix_nanos(pd.Timestamp.utcnow()),
            client_order_id=ClientOrderId(self.get(11).decode()),  # ClOrdID
            avg_px=Decimal(self.get(6).decode()),  # AvgPx
            price=Price(float(self.get(44)), instrument.price_precision)
            if self.get(44) is not None
            else None,  # Price
            trigger_price=Price(float(self.get(99)), instrument.price_precision)
            if self.get(99) is not None
            else None,  # StopPx
            cancel_reason=self.get(58).decode() if self.get(58) is not None else None,  # Text
        )


class OrderCancelReject(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "9"
        # self.append_pair(35, "9", header=True)


class Logon(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "A"
        # self.append_pair(35, "A", header=True)


class NewOrderSingle(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "D"
        # self.append_pair(35, "D", header=True)


class OrderCancelRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "F"
        # self.append_pair(35, "F", header=True)


class OrderCancelReplaceRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "G"
        # self.append_pair(35, "G", header=True)


class OrderStatusRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "H"
        # self.client_order_id = client_order_id
        # self.order_side = order_side

    @property
    def request_id(self) -> str | None:
        return self.get(790).decode() if self.get(790) is not None else None


class MarketDataRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "V"
        # self.append_pair(35, "V", header=True)


class MarketDataSnapshotFullRefresh(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "W"
        # self.append_pair(35, "W", header=True)


class MarketDataRequestReject(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "Y"
        # self.append_pair(35, "Y", header=True)


class TradeCaptureReportRequest(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "AD"
        # self.append_pair(35, "AD", header=True)

    @property
    def request_id(self) -> str | None:
        return self.get(568).decode() if self.get(568) is not None else None


class TradeCaptureReport(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "AE"
        # self.append_pair(35, "AE", header=True)

    @property
    def request_id(self) -> str | None:
        return self.get(568).decode() if self.get(568) is not None else None

    def to_nautilus(self, instrument: Instrument) -> TradeReport:
        # TODO LMAX XML api only returns incomplete orders, cannot get commission value
        return TradeReport(
            account_id=AccountId(f"LMAX-{int(self.get(1))}"),
            instrument_id=instrument.id,
            venue_order_id=VenueOrderId(self.get(37).decode()),  # OrderID
            trade_id=TradeId(self.get(527).decode()),  # SecondaryExecID
            order_side=parse_lmax_order_side(int(self.get(54))),  # Side
            last_qty=Quantity(float(self.get(32)), instrument.size_precision),  # LastQty
            last_px=Price(float(self.get(31)), instrument.price_precision),  # LastPx
            liquidity_side=LiquiditySide.TAKER,
            report_id=UUID4(),
            ts_event=parse_lmax_timestamp_ns(self.get(60).decode()),  #  TransactTime
            ts_init=dt_to_unix_nanos(pd.Timestamp.utcnow()),
            client_order_id=ClientOrderId(self.get(11).decode()),  # ClOrdID
            venue_position_id=None,  # LMAX netting position resolution
            commission=Money(0, instrument.base_currency),  # needed for reconciliation,
        )


class TradeCaptureReportRequestAck(FixMessage):
    def __init__(self):
        super().__init__()
        self.message_type = "AQ"
        # self.append_pair(35, "AQ", header=True)

    @property
    def request_id(self) -> str | None:
        return self.get(568).decode() if self.get(568) is not None else None


_MESSAGE_TYPE_MAP = {
    "0": Heartbeat,
    "1": TestRequest,
    "2": ResendRequest,
    "3": Reject,
    "4": SequenceReset,
    "5": Logout,
    "8": ExecutionReport,
    "9": OrderCancelReject,
    "A": Logon,
    "D": NewOrderSingle,
    "F": OrderCancelRequest,
    "G": OrderCancelReplaceRequest,
    "H": OrderStatusRequest,
    "V": MarketDataRequest,
    "W": MarketDataSnapshotFullRefresh,
    "Y": MarketDataRequestReject,
    "AD": TradeCaptureReportRequest,
    "AE": TradeCaptureReport,
    "AQ": TradeCaptureReportRequestAck,
}

_FIELD_MAP = {
    1: "Account",
    6: "AvgPx",
    7: "BeginSeqNo",
    8: "BeginString",
    9: "BodyLength",
    10: "CheckSum",
    16: "EndSeqNo",
    22: "SecurityIDSource",
    34: "MsgSeqNum",
    35: "MsgType",
    36: "NewSeqNo",
    43: "PossDupFlag",
    45: "RefSeqNum",
    48: "SecurityID",
    49: "SenderCompID",
    52: "SendingTime",
    56: "TargetCompID",
    58: "Text",
    89: "Signature",
    93: "SignatureLength",
    95: "RawDataLength",
    96: "RawData",
    97: "PossResend",
    98: "EncryptMethod",
    108: "HeartBtInt",
    112: "TestReqID",
    122: "OrigSendingTime",
    123: "GapFillFlag",
    141: "ResetSeqNumFlag",
    146: "NoRelatedSym",
    262: "MDReqID",
    263: "SubscriptionRequestType",
    264: "MarketDepth",
    265: "MDUpdateType",
    266: "AggregatedBook",
    267: "NoMDEntryTypes",
    268: "NoMDEntries",
    269: "MDEntryType",
    270: "MDEntryPx",
    271: "MDEntrySize",
    272: "MDEntryDate",
    273: "MDEntryTime",
    281: "MDReqRejReason",
    354: "EncodedTextLen",
    355: "EncodedText",
    371: "RefTagID",
    372: "RefMsgType",
    373: "SessionRejectReason",
    383: "MaxMessageSize",
    384: "NoMsgTypes",
    385: "MsgDirection",
    464: "TestMessageIndicator",
    553: "Username",
    554: "Password",
    789: "NextExpectedMsgSeqNum",
}

_FIELD_TYPE_MAP = {
    "0": Heartbeat,
    "1": TestRequest,
    "2": ResendRequest,
    "3": Reject,
    "4": SequenceReset,
    "5": Logout,
    "8": ExecutionReport,
    "9": OrderCancelReject,
    "A": Logon,
    "D": NewOrderSingle,
    "F": OrderCancelRequest,
    "G": OrderCancelReplaceRequest,
    "H": OrderStatusRequest,
    "V": MarketDataRequest,
    "W": MarketDataSnapshotFullRefresh,
    "Y": MarketDataRequestReject,
    "AD": TradeCaptureReportRequest,
    "AE": TradeCaptureReport,
    "AQ": TradeCaptureReportRequestAck,
}


def _identify_type(value: str) -> type | None:
    for pair in value.strip("|").split("|"):
        tag, value = tuple(pair.split("="))
        if tag == "35":
            return _MESSAGE_TYPE_MAP.get(value)
    return None
